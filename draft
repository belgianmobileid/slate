<blockquote>
<p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
<h2 id='authentication-request'>Authentication request</h2></blockquote>
<h3 id='basic-request'>Basic request</h3>
<p>Basic request is a &quot;Web Desktop&quot; where the itsme(r) App is not triggered manually by the end user.</p>

<p>For a basic request, specify the following parameters:
Parameter | Required | Comment
--------- | ------- | -----
<strong>client_id</strong> | Required | MUST be the Partner Code you obtained from BMID during on-boarding process and this value will be unique to each partner per environment. This information is in the on-boarding file provided by BMID. 
<strong>response_type</strong> | Required | MUST be <code>code</code>.
<strong>scope</strong> | Required | MUST contain at least <code>openid</code> or an HTTP ERROR <code>not_implemented</code> will be returned. <code>offline_access</code> value will yield an error. MUST also includes the target service in the form <code>service:&lt;SERVICE_CODE&gt;</code> as provided by BMID during the on-boarding process. <em>**Note</em><em>: Requested data will only be provided based on your current accesses</em>. These accesses are specified in the on-boarding file provided by BMID.
<strong>redirect_uri</strong> | Required | should be the HTTPS endpoint on your server that will receive the response from <strong>itsme(r)</strong>. This value MUST match one of the values provided to BMID during on-boarding process. <em>**Note</em><em>: the Partner can define different **redirect_uri</em>* specific to each Service.*
<strong>state</strong> | Optional, but strongly recommended | should include the value of the anti-forgery unique session token, as well as any other information needed to recover the context when the user returns to your application.
<strong>nonce</strong> | Optional | a random value generated by your app that enables replay protection when present.
<strong>login_hint</strong> | Optional | OPTIONAL and supported, though not recommended. Only phone numbers are supported as <code>login_hint</code>. Format is: <code>&lt;countrycode&gt;+&lt;phonenumber&gt;</code>. E.g. <code>login_hint=32+123456789</code>. Usage of claim value <code>phone_number</code> in an encrypted request object is recommended in order to avoid disclosure of phone number of the end user on the user agent (such as mobile app or web browser)
<strong>display</strong> | Optional | MUST be <code>page</code> if provided. Other values will yield an HTTP ERROR <code>not_implemented</code>.
<strong>prompt</strong> | Optional | MUST be <code>consent</code> if provided.
<strong>ui_locales</strong> | Optional | Can be used to specify the language to be used by the OpenID login page. Supported languages are: <code>fr</code>, <code>nl</code>, <code>en</code> and <code>de</code>. Any other value will be ignored.
<strong>max_age</strong> | Optional | Supported but not used: <strong>itsme(r)</strong> will always actively re-authenticate the End-User. 
<strong>acr_values</strong> | Optional | OPTIONAL and supported, though not recommended. Possible values are tag:itsmetag:sixdots.be,2016-06:acr_basic, tag:itsmetag:sixdots.be,2016-06:acr_advanced. When multiple values are provided only the most constraining will be used (advanced &gt; basic). If not provided basic level will be used. As there is no such idea of an existing session on itsme Core, even if the <code>acr_values</code> is requested as a voluntarily claim, the acr value returned will always be the more constraining method in the <code>acr_values</code> list, or the authentication will fail. Usage of acr parameter in the request object is recommended over this parameter as it will be signed in the JWT token
<strong>claims</strong> | Optional | Not recommended. Usage of claims parameter in the request object is recommended over this parameter as it will be signed in the JWT token, and the data will be encrypted
<strong>request</strong> | Optional | See <a href="#JWTRequest">Passing Request Parameters as JWTs</a>
<strong>response_mode</strong> | Unsupported | Ignored if provided.
<strong>id_token_hint</strong> | Unsupported | Ignored if provided.
<strong>claims_locales</strong> | Unsupported | None are supported.
<strong>request_uri</strong> | Unsupported | Not supported (yet)
<strong>registration</strong> | Unsupported | Not supported due to “client dynamic registration”is not supported. The client registration process is done during the partner onboarding.</p>

<blockquote>
<p>Example of a minimal Authorization request</p>
</blockquote>
<pre class="highlight plaintext"><code>GET /authorize?response_type=code
&amp;scope=openid%20profile%20email%20service%3Aclient.registration
&amp;client_id=s6BhdRkqt3
&amp;state=af0ifjsldkj
&amp;redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
Host: server.itsme.be
</code></pre>
<blockquote>
<p>Example of Authentication Response</p>
</blockquote>
<pre class="highlight http tab-http--inline"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">302</span> <span class="ne">Found</span>
<span class="na">Location</span><span class="p">:</span> <span class="s">https://client.example.org/cb?</span>
<span class="s">  code=SplxlOBeZQQYbYS6WxSbIA</span>
<span class="s">  &amp;state=af0ifjsldkj</span>
</code></pre><h3 id='specifics'>Specifics</h3><h4 id='specifics-to-login'>Specifics to Login</h4>
<p><strong>itsme(r) Login</strong> is based on the <a href="http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">Authorization Code Flow</a> of OpenID Connect 1.0.</p>

<p>The Authorization Code Flow goes through the following steps as defined in  <a href="http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowSteps">http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowSteps</a></p>
<h5 id='1-authentication-request'>1. Authentication Request</h5>
<p>As per the OpenID Connect specification <a href="http://openid.net/specs/openid-connect-core-1_0.html#AuthRequest">http://openid.net/specs/openid-connect-core-1_0.html#AuthRequest</a> and <a href="http://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint">http://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint</a></p>

<p>The first step is forming an HTTPS request with the appropriate URI parameters. Please note the use of HTTPS rather than HTTP in all the steps of this process; HTTP connections are refused. You should retrieve the base URI from the <a href="https://merchant.itsme.be/oidc/.well-known/openid-configuration">Discovery document</a> using the key <strong>authorization_endpoint</strong>. The following discussion assumes the endpoint is <code>https://merchant.itsme.be/oidc/authorize</code>.</p>

<p><strong>itsme(r)</strong> supports the use of the HTTP <code>GET</code> and <code>POST</code> methods. If using the HTTP <code>POST</code> method, the request parameters must be serialized using <a href="http://openid.net/specs/openid-connect-core-1_0.html#FormSerialization">Form Serialization</a>.
Login specification defined above in this document as follows,<br></p>

<p>##### Differences in the Authentication End Point (“oidc/authorization”)</p>

<ol>
<li>Authorization queries MUST be communicated using HTTP <code>POST</code> protocol ONLY using “application/x-www-form-urlencoded” media type. HTTP <code>GET</code>calls will be refused for approval OIDC requests. This is because in case of an approval action, the Authorization request can contain sensitive data.</li>
<li>Using the “request object” parameter is mandatory (parameter “request” in the authorization request query string).</li>
<li>The “request object” MUST be signed and encrypted by the service provider. Signed, using his private signing key and, encrypted using the itsme(r) OP public encryption key. The later can be found, of course, in the OP JWKSet JSON file.</li>
<li>Parameters encoded in the “request object” have priority over the same parameters put as a<code>GET</code> query parameter. If not explicitly required by the OIDC protocol, it is mandatory to put the corresponding parameter inside the “request object” instead of putting it as a simple form parameter (because the request object is signed and encrypted).</li>
<li>Each form parameter that is eligible to be present in the request object MUST also be encoded in the request object itself (because signed and encrypted).</li>
<li>Only service codes corresponding to a pre-registered “Approval” kind of service MUST be used in the ‘service’ scope parameter. Be sure this service was already created in the system during partner onboarding. </li>
<li>The “prompt” parameter can be “login” and/or “consent”.</li>
</ol>

<p>##### Differences in the Token End Point (“/oidc/token”)
 1. The Token end point MUST ALWAYS be called to validate that the authorization code received from the browser is a valid one and corresponds effectively to the approval transaction initiated by the SP.
 2. Then, the received IDToken MUST ALWAYS be validated by the SP as follow:
 a. Correctly unencrypted using the SP private key.
 b. The signature is effectively the one of the itsme(r) OP.
 c. The possibly embedded “nonce” value is the same as the one existing in the authorization request (if specified by the SP).
 d. If the user is already logged in the SP and, it is required that it is this user that validated the transaction, then the user identifier (sub value) must match the one of the currently logged user in the SP.</p>

<p>#####  Differences in the User Info End Point (“/oidc/userinfo”)</p>

<ol>
<li>Calling the “User Info” End Point is not mandatory. The “ID Token” already contains all the necessary proof for a simple approval.</li>
<li>However, the “User Info” End Point can be called to retrieve the requested claims of the user that did the approval. </li>
</ol>

<p>if the user is already logged in, two possible identifiers that could be used to:</p>

<ul>
<li>In the “userinfo” JSON section, the “<strong>sub</strong>” requested claim can be used to communicate the subject (end user) identifier already shared between itsme(r) OP and the SP. This identifier (called “user code”) was previously communicated in the ID token or in the UserInfo token after a successful OIDC login.</li>
</ul>
<h4 id='specifics-to-approval'>Specifics to Approval</h4>
<p>#####  OIDC Approval</p>

<p>During and OIDC `Approval, the connected user gives his consent on a particular action initiated by the SP, the content detail of this action is displayed on the mobile phone.<br>
  The idea of the OIDC Approval is to follow the OIDC specification and include this new concept in the protocol.</p>

<p>##### Differences with OpenID Connect Login
  The approval extension must fit into the official OpenID Connect specification. You will find below what are the differences with the login specification defined above in this document. The login specification must be understood first, before going further into the next paragraphs.</p>

<ul>
<li>In the “userinfo” JSON section, the “<strong>phone_number</strong>” requested claim can be used to communicate the subject (end user) phone number to be used as unique identifier. The format must match this regular expression</li>
</ul>
<pre class="highlight http tab-http--inline"><code><span class="err"> \\+?(\\d{1,3})[ +](\\d*)
</span></code></pre>
<p>Giving one of these two (valid) identifiers in the authorization request will bypass the identification screen where the end user should normally introduce his phone number to identify himself.</p>

<p>Only signed and encrypted valid* OIDC Approval request will lead to an identification screen bypass.</p>

<p><em>(*) Valid if the request was emitted by an active partner using one of his active approval services.</em></p>

<p>##### Sample OIDC approval authorization request using the “sub” identifier
 The value <code>THE_END_USER_ALREADY_KNOWN_USER_CODE</code> must be replaced with a valid user code. This code is the identifier shared between the itsme(r) OP and the SP to represent the end user. This identifier can be obtained after a successful OIDC login.</p>
<pre class="highlight http tab-http--inline"><code><span class="err">
 POST /oidc/authorization

 response_type=code

 client\_id=MY\_PARTNER_CODE

 scope=openid service:MY\_APPROVAL\_SERVICE_CODE

 redirect\_uri=https:\\/\\/service-provider.be\\/my\_call\_back\_url  
 nonce=A\_VALID\_NONCE  
 state=A\_VALID\_STATE  
 request={

 "response_type":"code",

 "client\_id":"MY\_PARTNER_CODE",

 "redirect\_uri":" https:\\/\\/service-provider.be\\/my\_call\_back\_url",

 "aud":"https:\\/\\/merchant.itsme.be\\/oidc",

 "scope":"openid service: MY\_APPROVAL\_SERVICE_CODE",

 "acr\_values":"tag:sixdots.be,2016-06:acr\_advanced",

 "iss":"MY\_PARTNER\_CODE",

 "nonce":"A\_VALID\_NONCE",

 "state":"A\_VALID\_STATE",

 "claims":{

 "userinfo":{

 "sub":{

 "value":"THE\_END\_USER\_ALREADY\_KNOWN\_USER\_CODE"

 },

 "tag:sixdots.be,2016-08:claim\_approval\_template_name":{

 "value":"adv_payment",

 "essential":true

 },

 "tag:sixdots.be,2016-08:claim\_approval\_amount_key":{

 "value":"100",

 "essential":true

 },

 "tag:sixdots.be,2016-08:claim\_approval\_currency_key":{

 "value":"EUR",

 "essential":true

 },

 "tag:sixdots.be,2016-08:claim\_approval\_iban_key":{

 "value":"BE00793774892029",

 "essential":true
 }
 }
 }
 }
</span></code></pre>
<p><em>Please note that the “request” parameter is represented as a regular JSON formatted object for clarity only. Because it must be correctly encoded, signed and then encrypted as explained in the official OIDC specification.</em></p>

<p>##### Sample OIDC approval authorization request using the “phone_number” identifier</p>

<p>The key <code>THE\_END\_USER\_PHONE\_VALUE</code> must be replaced with a valid user phone value.</p>
<pre class="highlight plaintext"><code>
 POST /oidc/authorization

 response_type=code

 client\_id=MY\_PARTNER_CODE

 scope=openid service:MY\_APPROVAL\_SERVICE_CODE

 redirect\_uri=https:\\/\\/service-provider.be\\/my\_call\_back\_url  
 nonce=A\_VALID\_NONCE  
 state=A\_VALID\_STATE  
 request={

 "response_type":"code",

 "client\_id":"MY\_PARTNER_CODE",

 "redirect\_uri":" https:\\/\\/service-provider.be\\/my\_call\_back\_url",

 "aud":"https:\\/\\/merchant.itsme.be\\/oidc",

 "scope":"openid service: MY\_APPROVAL\_SERVICE_CODE",

 "acr\_values":"tag:sixdots.be,2016-06:acr\_advanced",

 "iss":"MY\_PARTNER\_CODE",

 "nonce":"A\_VALID\_NONCE",

 "state":"A\_VALID\_STATE",

 "claims":{

 "userinfo":{

 "phone_number":{

 "value":"THE\_END\_USER\_PHONE\_VALUE"

 },

 "tag:sixdots.be,2016-08:claim\_approval\_template_name":{

 "value":"adv_payment",

 "essential":true

 },

 "tag:sixdots.be,2016-08:claim\_approval\_amount_key":{

 "value":"100",

 "essential":true

 },

 "tag:sixdots.be,2016-08:claim\_approval\_currency_key":{

 "value":"EUR",

 "essential":true

 },

 "tag:sixdots.be,2016-08:claim\_approval\_iban_key":{

 "value":"BE00793774892029",

 "essential":true

 }

 }

 }

 }
</code></pre>
<p><em>Please note that the “request” parameter is represented as a regular JSON formatted object for clarity only. Because it must be correctly encoded, signed and then encrypted as explained in the official OIDC specification.</em></p>

<p>Sample OIDC approval authorization request using the <code>phone_number</code> identifier In order to specify what must be approved by the end user, there are currently two templates that can be used in OIDC approval authorization requests…</p>

<p>The template to be used MUST be specified using his identifier in the dedicated OIDC requested claim.<br>
 Here is the key name: <code>“tag:sixdots.be,2016-08:claim\_approval\_template_name”</code>.</p>

<p>##### Template: “Advanced Payment”
 Approval template name: <code>“adv_payment“</code>
 As expected, the goal of this template is to request an (“advanced”) payment.</p>

<p>Expected parameters:</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Requested Claim Key Name</th>
<th>Claim Value Type</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Amount</strong></td>
<td><code>tag:sixdots.be,2016-08:claim_approval_amount_key</code></td>
<td>A string holding an integer value inside</td>
</tr>
<tr>
<td><strong>Currency</strong></td>
<td><code>tag:sixdots.be,2016-08:claim_approval_currency_key</code></td>
<td>A string holding a valid currency code (e.g. &quot;EUR&quot;).<br></td>
</tr>
<tr>
<td><strong>IBAN</strong></td>
<td><code>tag:sixdots.be,2016-08:claim_approval_iban_key</code></td>
<td>A string holding a valid IBAN account number.</td>
</tr>
</tbody></table>

<p>##### Template: “Free Text”</p>

<p>Approval template name: <code>“free_text”</code>
 As expected, the goal of this template is to be free deciding what is displayed on the end user phone.<br>
 Expected parameters:
 Parameter | Requested Claim Key Name | Claim Value Type
 -- | -- | --
 <strong>Text</strong> | <code>tag:sixdots.be,2016-08:claim_approval_text_key</code> | A string holding any text to be displayed on the end-user phone.<br></p>
<h4 id='app-to-app-specifics'>App to App specifics</h4>
<p>#### App to App authentication
 The itsme(r) App itself also leverages the OpenID Connect authentication flow to allow native apps to perform the authentication easily and safely.</p>

<p>By using this flow, the end user will be automatically redirected from your App (or your web page in the mobile browser) to the itsme(r)  App. After authenticating himself (or rejecting the authentication), he will be redirected back to your App.</p>

<p>This authentication flow is referred as &quot;App to App&quot; flow when occurring from your App to the itsme(r)  App, or &quot;Web Mobile&quot; flow when occurring from the mobile browser to the itsme(r) App. When the context is not ambiguous, we also use &quot;App to App&quot; denomination to designate both flows. We designate by &quot;Web Desktop&quot; the flow where the itsme(r) App is not triggered manually by the end user.</p>

<p>The technology used for this flow is the <a href="https://developer.apple.com/library/
%20content/documentation/General/Conceptual/AppSearch/UniversalLinks.html">Universal Links</a> (iOS)/<a href="https://developer.android.com/training/app-links/index.html">App Links</a> (Android).</p>

<p>In case the itsme(r) App is not present on the device, the end user will be redirected to a web page in the mobile browser, as per <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html">Universal Links</a> and <a href="https://developer.android.com/training/app-links/index.html">App Links</a> specifications. Currently, this web page redirects the end user to the OpenID web page of BMID, where he will be able to enter his phone number and continue the authentication flow.</p>

<p>#### Pre-requisites
 Universal Links are available on iOS since version 9.0, and the itsme(r)  App itself is only available on iOS 9.0 or greater.</p>

<p>App Links are available on Android since version 6.0. The itsme(r)  App is available on Android 4.2 or greater, and supports OpenID Connect authentication only on Android version 6.0 or greater. Please note that calling the mobile authorization endpoint on Android versions between 4.2 and 6.0 will lead to sub-optimal user experience or even a non-functional flow, depending on the OS and the actions of the end user.</p>

<p>#### Registering Universal/App Links</p>

<p>As per recommendations of <a href="https://tools.ietf.org/html/draft-ietf-oauth-native-apps-12">OAuth Working Group about the authentication process in native apps</a>. </p>

<p>BMID exclusively uses Universal/App Links for all communications between your App and itsme(r). Among other advantages, this mechanism guarantees that the right app is launched and thus improves the security.</p>

<p>If you trigger the itsme(r) App from your own App, you MUST make sure there is a Universal/App Link associated with your App. Please consult the  documentation about <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html">Universal</a>/<a href="https://developer.android.com/training/app-links/index.html">App</a> for this. This Universal/App Link MUST be specified to BMID during the onboarding process.</p>

<p>#### Authorization Request specifications
 Authorization Requests in the context of App to App and Web mobile to App flow must be addressed to <code>https://mobileapp.sixdots.be/mobile/authorize</code>, and they are subject to more strict specifications as Authorization Requests in  the  Web Desktop flow.</p>

<p>For a basic request, specify the following parameters. The changes compared to the Web Desktop flow are <strong><em>emphasized in this way</em></strong>:
 Parameter | Required | Comment
 --------- | ------- | -----
 <strong>client_id</strong> | Required | MUST be the Partner Code you obtained from BMID during on-boarding process and this value will be unique to each partner per environment. This information is in the on-boarding file provided by BMID. 
 <strong>response_type</strong> | Required | MUST be <code>code</code>.
 <strong>scope</strong> | Required | MUST contain at least <code>openid</code> or an HTTP ERROR <code>not_implemented</code> will be returned. <code>offline_access</code> value will yield an error. MUST also includes the target service in the form <code>service:&lt;SERVICE_CODE&gt;</code> as provided by BMID during the on-boarding process. <em>**Note</em><em>: Requested data will only be provided based on your current accesses</em>. These accesses are specified in the on-boarding file provided by BMID.
 <strong>redirect_uri</strong> | Required | <strong><em>Should be the Universal/App Link registered for your App. If you only intend to use the mobile browser, the redirect_uri should then be should be the HTTPS endpoint on your server that will receive the response from</em></strong> <strong>itsme(r)</strong>. This value MUST match one of the values provided to BMID during on-boarding process. <em>**Note</em><em>: the Partner can define different **redirect_uri</em>* specific to each Service.*
 <strong>state</strong> | <strong><em>Required</em></strong> | should include the value of the anti-forgery unique session token, as well as any other information needed to recover the context when the user returns to your application.
 <strong>nonce</strong> | <strong><em>Required</em></strong> | a random value generated by your app that enables replay protection when present. This value can only be used once per authentication.
 <strong>login_hint</strong> | Optional | OPTIONAL and supported, though not recommended. Only phone numbers are supported as <code>login_hint</code>. Format is: <code>&lt;countrycode&gt;+&lt;phonenumber&gt;</code>. E.g. <code>login_hint=32+123456789</code>. Usage of claim value <code>phone_number</code> in an encrypted request object is recommended in order to avoid disclosure of phone number of the enduser on the user agent (such as mobile app or web browser). <strong><em>In App to App flow, it will only be used if the itsme(r) App is not installed on the end user device.</em></strong>
 <strong>display</strong> | Optional | MUST be <code>page</code> if provided. Other values will yield an HTTP ERROR <code>not_implemented</code>.
 <strong>prompt</strong> | Optional | MUST be <code>consent</code> if provided.
 <strong>ui_locales</strong> | Optional | Can be used to specify the language to be used by the OpenID login page. Supported languages are: <code>fr</code>, <code>nl</code>, <code>en</code> and <code>de</code>. Any other value will be ignored.
 <strong>max_age</strong> | Optional | Supported but not used: <strong>itsme(r)</strong> will always actively re-authenticate the End-User. 
 <strong>acr_values</strong> | Optional | OPTIONAL and supported, though not recommended. Possible values are tag:itsmetag:sixdots.be,2016-06:acr_basic, tag:itsmetag:sixdots.be,2016-06:acr_advanced. When multiple values are provided only the most constraining will be used (advanced &gt; basic). If not provided basic level will be used. As there is no such idea of an existing session on itsme(r)  Core, even if the <code>acr_values</code> is requested as a voluntarily claim, the acr value returned will always be the more constraining method in the <code>acr_values</code> list, or the authentication will fail. Usage of acr parameter in the request object is recommended over this parameter as it will be signed in the JWT token/
 <strong>claims</strong> | Optional | Not recommended. Usage of claims parameter in the request object is recommended over this parameter as it will be signed in the JWT token, and the data will be encrypted
 <strong>request</strong> | <strong><em>Required</em></strong> | See <a href="#JWTRequest">Passing Request Parameters as JWTs</a>. <strong><em>This parameter MUST be signed then encrypted.</em></strong> 
 <strong>response_mode</strong> | Unsupported | Ignored if provided.
 <strong>id_token_hint</strong> | Unsupported | Ignored if provided.
 <strong>claims_locales</strong> | Unsupported | None are supported.
 <strong>request_uri</strong> | Unsupported | Not supported (yet)
 <strong>registration</strong> | Unsupported | Not supported due to “client dynamic registration”is not supported. The client registration process is done during the partner onboarding.</p>

<p>#### Authorization Response specifications
 Once the authentication is finished (successfully or not), itsme(r) will open the Universal/App Link indicated in the <strong>redirect_uri</strong>. If this <strong>redirect_uri</strong> is not registered as a Universal/App Link on your side, it will be opened as a URL in theinterpreted as an default mobile browser.</p>

<p>The content of the Authorization Response is exactly the same as per Web Desktop flow.</p>

<blockquote>
<h1 id='faq'><strong>FAQ</strong></h1><h2 id='jwkset'>JWKSet</h2><h3 id='what-is-a-jwkset'>What is a JWKSet?</h3>
<p>We require you to expose a set of public key (a signature key &amp; one encryption key) to setup the connectivity.</p>
</blockquote>

<p>For example our E2E JWKSet is here https://e2emerchant.itsme.be/oidc/jwkSet. We need the Service Provider to expose some similar content – on a very public https endpoint (nothing is confidential in there).</p>

<p>The signature key is used to verify the Service provider when they come fetch data on a client.<br>
 The encryption key is used to encrypt data so that nobody can read the data which we are transfering apart from the service provider component who has the right to access these data (so that you can encode/reencode the https in intern in a less secured component; it stays crypted).</p>

<p>If the question is ONLY related to OpenID Connect (OIDC) aspects,</p>

<blockquote>
<p><em>“For signature and encryption, does BMID accept either RP self-signed certificates or certificates signed by an internal PKI (in which case we need to provide also our internal CA certificate)?”</em></p>

<p><em>The RP (the partner) provides his public key used for encryption and the other one used for signature of OIDC JWT (= JSON Web Tokens), using a JSON file called “JWKSet”. (sample JWKSet for Itsme OpenID Provider)</em></p>

<ul>
<li>This JWKSet is accessible, using a secured HTTPS URL.
(sample HTTPS URL for OpenID Provider https://merchant.itsme.be/oidc/jwkSet)</li>
</ul>
</blockquote>

<ul>
<li>This HTTPS URL must be communicated to us, during the partner on-boarding.<br></li>
<li>This HTTPS URL must be protected using a valid certificates chain starting from a Root CA trusted by our backend.
&gt;
During on-boarding, we can check that we have all the required certificates to establish the trust.<br>
So, on the HTTPS protocol level, the connections must be secured using trusted Root CA (not self-signed).
In contrary, the key pairs used for signing and/or encrypting the OIDC JWT tokens can be self-signed.</li>
</ul>

<blockquote>
<h3 id='how-to-create-jwkset'>How to create JWKSet?</h3></blockquote>

<p>The following JSON Web Key Generator can be used to create JWKSet
  <code>
 https://mkjwk.org/ 
</code>
 Another resource you could use to generate your JWKSet is: 
  <code>
 https://connect2id.com/products/nimbus-jose-jwt/examples/jwk-generation
</code>
 Another option (using python) is available at:
  <code>
 https://stackoverflow.com/questions/42504079/how-do-you-extract-n-and-e-from-a-rsa-public-key-in-python
</code> </p>

<blockquote>
<h3 id='how-to-transfer-jwksets'>How to Transfer JWKSets?</h3>
<p>The following link can be used to convert encoded public and private keys to JWKSet format:
  <code>
 https://www.npmjs.com/package/rsa-pem-to-jwk
</code></p>
<h3 id='what-are-the-jwkset-requirements'>What are the JWKSet requirements?</h3>
<p>In Opend ID Connect 1.0 the important is the jwKset which is exposed on a public URL and the linked chain of certificates which is included in our trust store.</p>

<p>This is 1 per partner. So in UAT 1, in Prod, for your 4 clients, it would be 1 JWKSet if it&#39;s under Norbloc name or 4 JWKSet if it&#39;s under each client name.</p>

<p>When you send request to us,</p>
</blockquote>

<ul>
<li>You sign the request with your &#39;sign&#39; private key and to encrypt it you use our &#39;encryption&#39; public key.</li>
<li>Once we answer your request, we send an encrypted JWT token (based on your &#39;encryption&#39; public key) which needs to be decrypted with your &#39;encryption&#39; private key. </li>
<li>Once decrypted, you need to validate our signature with our &#39;public&#39; sign key found in our JWKSet.</li>
</ul>

<p>We are here working in HTTPS Client Authentication.For more details the best is to refer to the Open ID Connect documentation(http://openid.net/connect/) - and more specifically follow links relating JWT encryption &amp; signing.</p>

<p>For the call back URI (not URL) you will need in UAT 4 URI, one per service. So in Prod, for 4 clients using each the 4 services, you would have at least 16 Service codes.</p>

<blockquote>
<h3 id='what-are-the-jwkset-encryption-requirements'>What are the JWKSet encryption requirements?</h3>
<p>In the JWKSet, encryption should be done with <strong>RSA256</strong>,  the signature in <strong>SHA256</strong> (in short the encryption algorithm is RS256) and the key size is 2048 bits.</p>
</blockquote>

<p>As a comparison here&#39;s the public keys for itsme UAT JWKSet.<br/></p>

<blockquote>
<p><strong>JWKSET itsme(r) UAT</strong></p>
</blockquote>
<pre class="highlight json tab-json--inline"><code><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="s2">"keys"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
 </span><span class="p">{</span><span class="w">
 </span><span class="s2">"kty"</span><span class="p">:</span><span class="w"> </span><span class="s2">"RSA"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"e"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AQAB"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"use"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sig"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"kid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"s1"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"n"</span><span class="p">:</span><span class="w"> </span><span class="s2">"46FaPodZLqflpnRlFpxwDWT7WNweWAtJ_QYJML2XjB71AlgW20D97VekezlxIudYXbp3aNSkIBcaBQGhzTNHQWuBPwTfemeH9KC2iOTEm3Bu2CsAtaeLzAJT2BjSC2Q4ZUAP2pUq1UQh1XoqjzViXzZIRV35eesKZD301bPsJ6E4z4VKkuzcCeG4jIicNWmbWjkdbdhDe39Ja-BhZrhRmfeoVUe_h2SuplVip4MycLggaO89LomHWF7GktNsmHkt1xOtBgWeCNYj7exXSegoR-29HMS4lzFielxOlr3K0oS8ImMHx-6aRbe3635vfn6Jy6Q9_uAlbWTUsdtFhnpofw"</span><span class="w">
 </span><span class="p">},</span><span class="w">
 </span><span class="p">{</span><span class="w">
 </span><span class="s2">"kty"</span><span class="p">:</span><span class="w"> </span><span class="s2">"RSA"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"e"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AQAB"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"use"</span><span class="p">:</span><span class="w"> </span><span class="s2">"enc"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"kid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"e1"</span><span class="p">,</span><span class="w">
 </span><span class="s2">"n"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rvwzdu-sVCABIgd4plRfoLifTZw6K7JKHuA8HeSgJvUYDUk5MPA7xNKQ5xIXyxisKUzMqIeGaWuaHoFTg4uy-mBFOpm-vG5yGr5GdMCtsA1Ub80x_MmdbkUG3MFsGqz7hE4VpQw0docrrsoS2D9plAMpGA3-_a2u6T1fxomBY5_sxFvyW3erkvjFPG3waU3b34txVIEvdZ6KAjAWR57Y6C749T6ky0eL_uBvPwcq9xmQ6O327MKU8sakEBXb57KDqe4Vm8CbezwIUAC23ia5sO1grqlJGDZW_dbosTcggCxgHW7m6j9RdkGR_mnmECukitwlNvXeCLQPFSunlUh52Q"</span><span class="w">
 </span><span class="p">}</span><span class="w">
 </span><span class="p">]</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span></code></pre>
<p>You can find the configuration parameters in in document « 33020 Technical Specification Service Provider OpenID Documentation » or via the following back-end URL:</p>

<p>https://uatmerchant.sixdots.be/oidc/.well-known/openid-configuration<br> </p>

<blockquote>
<h3 id='what-should-i-do-once-i-changed-my-jwkset'>What should I do once I changed my JWKSet?</h3>
<p>Please notify Support and create a new certificate.</p>
<h3 id='what-should-i-do-once-i-changed-my-jwkset-but-not-the-url-does-it-mean-no-new-certificates'>What should I do once I changed my JWKSet but not the URL, does it mean no new certificates?<br></h3>
<p>You should contact support and mention the change to allow a refresh of the cache on back-end side, this should be solved in March where the refresh time will be 30 min.</p>
</blockquote>

<p>A workaround to force a refresh, let the SP send a request with an unknown <strong>&quot;KID&quot;</strong> (key id).<br>
 Because not found in the current cache, this one will be refreshed. But the client has to correct his JWKSet first, if not yet done. </p>

<blockquote>
<h2 id='certificate'><strong>CERTIFICATE</strong></h2><h3 id='what-is-the-use-of-our-certificate'><strong>What is the use of our Certificate?</strong></h3>
<p>Certificate is used to retrieve your JWKSet. We don&#39;t need client certificate, just root and intermediate CA and final public certificate.<br>
 For testing, you could use a self signed certificate like that you could define validity period. </p>
<h3 id='what-format-does-the-certificate-need-to-be'><strong>What format does the certificate need to be?</strong></h3>
<p>It needs to be a ZIP file,  X509 format (cer or crt). <em>(Not a pem file)</em></p>
<h3 id='can-i-use-a-self-signed-certificate-for-my-integration'><strong>Can I use a self signed certificate for my integration?</strong></h3>
<p>In Sandbox - <strong>Yes</strong> 
 In Production - <strong>No</strong>, for production we need the certificate &amp; its intermediate chain.</p>
<h3 id='should-i-notify-bmid-if-the-certificate-is-changed'><strong>Should I notify BMID if the certificate is changed?</strong></h3>
<p>Yes, BMID should be notified immediately.</p>
<h3 id='can-a-same-service-point-to-separate-ssl-certificates'><strong>Can a same service point to separate SSL Certificates?</strong></h3>
<p>Currently, the certificate is used to protect the JWKSet and is not directly linked to the SSL certificate, so for one Partner code you have maximum 1 JWKSet.</p>
<h2 id='authentication'>AUTHENTICATION</h2><h3 id='do-we-need-a-app-client-secret-on-the-openid-client'>Do we need a App Client Secret on the OpenID client?</h3></blockquote>

<p>OpenID allows multiple ways for authentication as a Service ProviderWe only support the private_key_jwt, with all the SSL requirements exposed via JWKSet, use the corresponding private key to encrypt/sign and decrypt/validate exchanged information.<br>
 So other authentication ways such as client_secret (Open ID Connect default method but the less secured one)</p>

<blockquote>
<h3 id='what-does-two-factor-authentication-mean'>What does two factor authentication mean?</h3>
<p>Two factor means:  </p>
</blockquote>

<p>You must provide at least two from this list :<br>
 - <strong>knowledge</strong> (something you know), Eg. password<br>
 - <strong>possession</strong> (something you have), Eg. mobile phone<br>
 - <strong>inherence</strong> (something you are). Eg. biometrics  </p>

<p>With standard login/password on web app : you only have to provide something you know (i.e. the password).  </p>

<p>With itsme, web2app, you obviously have two factors : the itsme PIN and the mobile device.<br>
-With app2app, it is still the same, as the two apps needs to be running on the same smartphone. Therefore, the attacker needs the device to initiate any malicious transaction. So there are still two factors : you must possess the mobile AND know the PIN.<br>
+With app2app, it is still the same, as the two apps need to be running on the same smartphone. Therefore, the attacker needs the device to initiate any malicious transaction. So there are still two factors : you must possess the mobile AND know the PIN.  </p>

<p>When you say (or your customer says) “Since you no longer need a second device to do the confirmation.” It is a miscomprehension of two factors. You don’t need to possess two things.  </p>

<p>Aside of that there&#39;s:<br>
 With Rogue Apps, an attacker can attempt to intercept Codes, PIN, transaction details and (try to …) replay them: No need to “Possess” the Compromised Device, and attacker will in time obtain “Knowledge” of the PIN, compromising the 2 factors required. In theory this remains possible.  </p>

<p>So far for theory: We acknowledge this risk, treat it accordingly, and test if it works. itsme’s apps (iOS and Android) are safeguarded to detect device compromises (and block). On top, even when compromised, make it (extremely) difficult to intercept the PIN, or replay transactions. As the official test by French ANSSI Authorities state it, for Gemalto’s SDK on Android: “Even if root rights obtained, PIN cannot be obtained to generate OTP / Authentication Response”.</p>

<blockquote>
<h2 id='call'>CALL</h2><h3 id='how-does-the-call-work'>How does the call work?</h3></blockquote>

<p>For each Partner 1 JWKSet per environment (Sandbox &amp; PROD) exposed on a public (https protected) URL.  </p>

<p>The full certificate chain of the server hosting the JwkSet file must be communicated so we can add it in our own trust store.  </p>

<p>When you send a request to us,<br>
 - Sign request with your &#39;signing&#39; private key<br>
 -  Encrypt it based on our &#39;encryption&#39; public key.  </p>

<p>We will decrypt your request with our &#39;encryption&#39; private key and use your &#39;sign&#39; public key for the signed part.  </p>

<p>Once we answer your request, we send an encrypted JWT token based on your &#39;encryption&#39; public key<br>
 - Decrypt request with your &#39;encryption&#39; private key<br>
 -  Validate our signature with our ‘signing’ public key found in our JWKSet</p>

<blockquote>
<h3 id='should-there-be-2-calls-to-itsme-for-this-schedule-one-for-token-request-amp-one-for-userinfo-request'>Should there be 2 calls to itsme for this schedule?(One for Token request &amp; one for Userinfo request)</h3>
<p>You need to perform two Back-End to Back-End calls indeed:</p>
</blockquote>

<p>- The Token Request<br>
 - The UserInfo Request  </p>

<p>On top of this, the Authorization Request (AuthN Request in the schedule) consists of an HTTP redirection to the OpenID webpage of BMID. The content of this HTTP request is to be crafted by your system, it is actually a third call from your side to BMID, this one being Front-End to Back-End.</p>

<blockquote>
<h3 id='how-to-set-the-level-of-security-at-the-level-of-the-app-5-digit-code-only-without-fingerprint-or-facial-recognition-eg'>How to set the level of security at the level of the App? (5 digit code only without fingerprint or facial recognition eg.)</h3>
<p>You can configure this option through the parameter “acr_values”, documented in the section 2.1.2.1 of the document <em>“33020 Technical Specification Service Provider OpenID”</em>.  </p>
</blockquote>

<p>Two values are supported:<br>
 <code>tag:sixdots.be,2016-06:acr_basic</code> : Basic level will let the User the choice to use either fingerprint (if Device is compatible) or his PIN.<br>
 <code>tag:sixdots.be,2016-06:acr_advanced</code>: Advanced level will force the User to use her/his PIN.</p>

<blockquote>
<h3 id='is-there-any-net-sample-code-available'>Is there any .NET sample code available?</h3>
<p>Please check the following link,</p>
</blockquote>

<p>https://docs.microsoft.com/en-us/aspnet/core/migration/1x-to-2x/identity-2x</p>

<blockquote>
<h3 id='is-get-request-supported'>Is <code>GET</code> request supported?</h3>
<p>No, only <code>POST</code> request is supported.</p>
<h3 id='why-app-to-backend-communication-exists-but-a-app-to-b2b-connection-does-not'>Why App-to-Backend communication exists but a App-to-B2B connection does not?</h3>
<p>We are sending the user information not through an app but through a highly authenticated server (which implies to put in place necessary measure to protect the data confidentiality)  </p>
</blockquote>

<p>This condition implies the need to put in place a back-end layer on your side.  </p>

<p>We require you to expose a set of public key (a signature key &amp; one encryption key) otherwise we cannot setup the connectivity with them.  </p>

<p>For example our E2E JWKSet is here https://e2emerchant.itsme.be/oidc/jwkSet. We need the Service Provider to expose some similar content – on a very public https endpoint (nothing is confidential in there).</p>

<blockquote>
<h3 id='which-information-must-be-present-to-contact-the-token-endpoint'>Which information must be present to contact the token endpoint?</h3></blockquote>

<p>-  This is a <code>POST</code> request and not a <code>GET</code>;</p>

<p>- In header the Content-Type : <em>application/x-www-form-urlencoded</em> must be added.</p>

<blockquote>
<h3 id='is-token-encryption-mandatory'>Is token encryption mandatory?</h3>
<p>We require you to expose a set of public key (a signature key &amp; one encruption key) otherwise we cannot setup the connectivity with them.  </p>
</blockquote>

<p>For example our E2E JWKSet is here https://e2emerchant.itsme.be/oidc/jwkSet. We need the Service Provider to expose some similar content – on a very public https endpoint (nothing is confidential in there)  </p>

<p>The signature key is used to verify the Service provider when they come fetch data on a client.<br>
 The encryption key is used to encrypt data so that nobody can read the data which we are transfering apart from the service provider component who has the right to access these data (so that you can encode/reencode the https in intern in a less secured component; it stays crypted).  </p>

<p><em>Document 33020 Technical Specifications Service Provider Open ID</em> should help you go further. Otherwise standard Open ID documentation (http://openid.net/connect/) should also help you.</p>

<blockquote>
<h2 id='test-application'>Test Application</h2><h3 id='after-installing-itsme-uat-through-hockey-app-on-iphone7-i-get-this-message-quot-non-trusted-company-app-developer-quot-what-should-i-do'>After installing Itsme-UAT through Hockey-app on iPhone7, i get this message:&quot;Non-trusted company app developer&quot;. What should i do?</h3>
<p>To be able to use itsme on Hockey App, you need to :  </p>
</blockquote>

<p>Select : “Annuleer”<br>
 Go to your settings<br>
 Select : General<br>
 Select : Profiles &amp; Device Management<br>
 Select : Belgian Mobile ID NV<br>
 Select : Trust</p>

<blockquote>
<h3 id='can-i-have-my-own-itsme-app-production-together-with-the-itsme-uat-app'>Can I have my own itsme app (production) together with the itsme UAT app?</h3>
<p>No, you can only have 1 itsme(r) app on your device one at a time, regardless of the which environment you have E.g. Production, UAT or E2E.</p>
<h3 id='is-this-page-auto-generated-https-uatmerchant-sixdots-be-oidc-well-known-openid-configuration'>Is this page auto generated: https://uatmerchant.sixdots.be/oidc/.well-known/openid-configuration?</h3>
<p>Yes, this page is auto-generated by the back end. But the content is mainly composed of hard coded values, only the environment specific values (like URLs) are loaded from config files. It is a summary of the parameters used for BMID implementation of OpenID Connect standard (supported encryption types, list of supported claims and scope values, endpoints).</p>
<h3 id='what-is-the-purpose-of-the-https-uatmerchant-sixdots-be-oidc-register-seems-to-be-a-link-to-be-registered-as-a-sp-but-do-we-make-use-of-it'>What is the purpose of the https://uatmerchant.sixdots.be/oidc/register? Seems to be a link to be registered as a SP, but do we make use of it?</h3>
<p>We do not use this. It is part of the OIDC standard. Normally used to register new OIDC partner. The registering process is done by an administrator (“the back end team” for the moment) during the “partner on boarding process”.</p>
<h3 id='is-it-possible-to-register-multiple-valid-callback-uris-jwkset-uris-for-one-environment-or-will-they-have-to-change-this-every-time-they-switch-uris'>Is it possible to register multiple valid callback URIs/jwkset URIs for one environment, or will they have to change this every time they switch URIs?</h3>
<p>While it is possible to register several redirect urls, it is not possible to register several jwkset urls.<br>
 The redirect url is specified in each Authorisation request, the User will be redirected to that url after the (failed or successful) authentication in the itsme(r) App. You need to specify it in the onboarding file because it needs to be white-listed by our F5. We can white-list several URLs. The JWKSet URLs, however, is used by our BE for the decryption and signature verification of the JWTokens present in the OpenID Connect flow. Our BE must know what URL to contact, and thus we can register only one JWKSet URL.</p>
<h3 id='when-the-end-user-is-redirected-to-itsme-r-in-the-browser-then-we-specify-a-redirect_uri-we-have-to-provide-bmid-the-redirect-uri-s-can-we-give-additional-parameters-or-does-the-entire-redirect_uri-needs-to-match'>When the end-user is redirected to itsme(r) in the browser, then we specify a redirect_uri. We have to provide BMID the redirect URI’s. Can we give additional parameters? Or does the entire redirect_uri needs to match?”</h3>
<p>The entire redirect_uri must match therefore no additional parameter is allowed.</p>
<h3 id='has-itsme-app-in-prod-amp-uat-different-url-scheme-39-s-eg-itsme-itsmeuat'>Has itsme app in Prod &amp; UAT different URL-scheme&#39;s?  eg itsme://...  itsmeUAT://...</h3>
<p>On iOS:<br>
 - for enrollment, it&#39;s always &quot;be.bmid.itsme://&quot; &quot;<br>
 - for App to App actions, it&#39;s based on universal links and these are different for each environment:<br>
 UAT<br>
 https://uatmobileapp.sixdots.be/mobile/processAction<br>
 https://uatmobileapp.sixdots.be/mobile/authorize<br>
 E2E<br>
 https://e2emobileapp.sixdots.be/mobile/processAction<br>
 https://e2emobileapp.sixdots.be/mobile/authorize<br>
 PRD<br>
 https://mobileapp.sixdots.be/mobile/processAction<br>
 https://mobileapp.sixdots.be/mobile/authorize</p>
<h2 id='service'>SERVICE</h2><h3 id='can-we-re-use-the-same-service-for-another-environment'>Can we re-use the same service for another environment?</h3>
<p>No, we will create new services for the OIDC.</p>
<h3 id='can-we-re-use-the-same-service-but-seperate-ssl-certificate'>Can we re-use the same service, but seperate SSL certificate?”</h3>
<p>Currently, the certificate is used to protect the jwkset and is not directly linked to the SSL certificate, so for one Partner code you have maximum 1 JWKSET. If my understanding is correct they want to use a service using the Belfius Partner Code.</p>
<h3 id='company-a-and-b-have-a-joint-project-login-with-itsme-for-the-website-c'>Company A and B have a joint project : login with ItsMe for the website “C”.</h3>
<p>This is a joint project because C reuses the front-application layer of B, ans also backend systems of B.<br>
 B is with regard to ItsMe an “identity provider”, whereas C is a “service provider”.  </p>
<h3 id='does-sixdots-agree-that-b-connectivity-platform-is-used-by-c-to-call-the-get-token-and-the-user-info-services'>Does SixDots agree that B connectivity platform is used by C to call the “get token” and the “user info” services ?</h3></blockquote>

<p>This platform is already processing calls from SixDots to B and from B to SixDots (enrollment of B customers via their mobile device).  </p>

<p>This implies that C would reuse the current ssl communication channel between B’ s connectivity platform and sixDots.  </p>

<p>Note: B uses SOAP. C would use Open Id Connect.</p>

<blockquote>
<p>We require that you present a dedicated SSL certificate so that we can distinguish the different calls in the logs &amp; we could revoke access per service.</p>
<h2 id='should-i-notify-bmid-if-the-ip-changes'>Should I notify BMID if the IP changes?</h2>
<p>No, this is not required.</p>
<h2 id='what-is-the-lay-out-of-the-identity-data-that-we-get-back-in-the-userinfo-response'>What is the lay-out of the Identity Data that we get back in the Userinfo Response</h2>
<p>They are the same as on the eID card</p>
<h2 id='do-we-need-to-call-the-userinfo-endpoint-to-get-the-national-register-number-or-can-it-be-part-of-the-id-token'>Do we need to call the UserInfo endpoint to get the National Register number or can it be part of the ID Token?</h2></blockquote>

<p>UserInfo should be used to retrieve data and so NRN if it was available, however, today we cannot send the NRN to private organizations.</p>

<blockquote>
<h2 id='i-would-like-the-access-to-the-nrn-data-but-not-other-eid-data-is-it-possible'>I would like the access to the NRN data but not other eID data, is it possible?</h2>
<p>Taking into account you allowed to receive the NRN from us, we can&#39;t and get access to NRN and block the access to the eID group else it would prevent you to receive the NRN.</p>
<h2 id='error-token-endpoint-unauthorized_client-what-should-i-do'>Error: Token endpoint - unauthorized_client. What should I do?</h2>
<p>The client_assertion you have to provide is expected to contain a body section AND a HEADER one.  </p>
</blockquote>

<p>The header must contain the following information:<br>
   <code>json--inline
 {  
 &quot;alg&quot;: &quot;&lt;THE\_ALGO\_YOU_USED&gt;&quot;,  
 &quot;typ&quot;: &quot;JWT&quot;,  
 &quot;kid&quot;: &quot;&lt;THE\_KEY\_ID\_YOU\_USED\_TO\_SIGN&gt;&quot;  
 }  
</code> </p>

<p><strong>Please make sure that,</strong></p>

<blockquote>
<p><strong>You provide this information in the encrypted assertion</strong>
 <strong>You signed also the assertion before encrypting it</strong>
 <strong>You  mention the correct &quot;kid&quot;, the &quot;alg&quot; and the constant value &quot;JWT&quot;</strong></p>
<h2 id='i-make-a-call-to-the-token-endpoint-the-server-returns-a-500-what-should-i-do'>I make a call to the token endpoint, the server returns a 500. What should I do?</h2></blockquote>

<p>I make a call to the token endpoint, (https://uatmerchant.sixdots.be/oidc/token) with the following params:<br>
 <code>json--inline
 grant\_type=authorization\_code&amp;code=80fmc3ydci8vuid18oh61l8hq33dwszhni0n&amp;redirect\_uri=https%3A%2F%2Fixxx-nodejs-itsme-poc.herokuapp.com%2Fapi%2Fitsme%2Flogin&amp;client\_assertion=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3MzAxZDg2Zi0yNjEzLTQ2MDAtOTA4ZS0wYmE2MWZkODQ3YjQiLCJpYXQiOjE1MTYxODUwNzEsImV4cCI6MTUxNjE4ODY3MSwiYXVkIjoiaHR0cHM6Ly91YXRtZXJjaGFudC5zaXhkb3RzLmJlL29pZGMvdG9rZW4iLCJpc3MiOiJJQ0FQUFMiLCJzdWIiOiJJQ0FQUFMifQ.L68iMbrrt0ETNBTJtBTCD29d0vKAyxPQ\_6lnBibtlB0&amp;client\_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer  
</code> </p>

<blockquote>
<p>The JWT token, encrypted with our private key, contains:  </p>
</blockquote>
<pre class="highlight json tab-json--inline"><code><span class="w">
 </span><span class="err">decoded</span><span class="w"> </span><span class="p">{</span><span class="w">  

 </span><span class="s2">"jti"</span><span class="p">:</span><span class="w"> </span><span class="s2">"7301d86f-2613-4600-908e-0ba61fd847b4"</span><span class="p">,</span><span class="w">  

 </span><span class="s2">"iat"</span><span class="p">:</span><span class="w"> </span><span class="mi">1516185071</span><span class="p">,</span><span class="w">  

 </span><span class="s2">"exp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1516188671</span><span class="p">,</span><span class="w">  

 </span><span class="s2">"aud"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://uatmerchant.sixdots.be/oidc/token"</span><span class="p">,</span><span class="w">  

 </span><span class="s2">"iss"</span><span class="p">:</span><span class="w"> </span><span class="s2">"xxx"</span><span class="p">,</span><span class="w">  

 </span><span class="s2">"sub"</span><span class="p">:</span><span class="w"> </span><span class="s2">"xxx"</span><span class="w">  

 </span><span class="p">}</span><span class="w">  
</span></code></pre>
<blockquote>
<p>The server returns a 500. No extra information.</p>
</blockquote>

<p>### Solution:
 The &quot;/token&quot; end point must be called using:  </p>

<p>(1)  &quot;application/x-www-form-urlencoded&quot; content type.  </p>

<p>The following type should not be used. &quot;<em>/</em>, Accept: application/json,text/plain,<em>/</em>,.&quot;  </p>

<p>(2) The returned media type will be &quot;application/json&quot;. <em>Please make sure to accept it in the request.</em> </p>

<p>(3) <code>POST</code> is the only http method allowed to call this entry point. Do not use <code>GET</code>.  </p>

<p>(4) Please make sure that your private key is not used to encrypt the JWT token.</p>

<p>You need to use your private key to firstly, sign the token, then use the itsme(r) encryption public key to encrypt the  token. The itsme(r) backend will then use his own private encryption key to decode your token and your public  signing key to validate your signature.</p>

<blockquote>
<h2 id='we-would-like-to-integrate-itsme-r-but'>We would like to integrate itsme(r) but..</h2>
<p>We would like to integrate itsme(r) but we only have 1 development machine &amp; so no unique IP for the back-end in test as it isn&#39;t unique &amp; runs in local on each machine.</p>
</blockquote>

<p>We need you to provide us a machine name (URL with host-name) so that once the redirect received, it points to your machine. On your local machine, this URL with host-name must point to your local machine (/ ETC / HOSTS) In other words: This will be the only URI we will accept in OpenID queries. So, if it is to be able to use the solution from different dev machines, the best thing is to create a unique redirect_uri like <code>https: // my-dev-sp / mycallbackuri</code> and that each developer maps <code>my-dev-sp</code> on the 127.0.0.1 via its hosts file.</p>

<p>For the rest, if each developer has the private key of the SP on his post, she/he can impersonate the SP during calls to &quot;/ token&quot; and &quot;/ userinfo&quot;. There is no check on the source IP, only the signature JWT account.</p>

<blockquote>
<h3 id='i-would-like-to-receive-a-new-service-code-to-do-my-local-development'>I would like to receive a new service code to do my local development.</h3></blockquote>

<p>So we would need a service code for the register operation with the following callback URL: http://localhost:23874/web2app/Identify/IdentificationCallBack  </p>

<p>First, you need to  validate that you are able (and <strong>authorized</strong>) to keep the &quot;xxx UAT JWKset signing and encryption private keys&quot; on your local machine because you will need them to sign the requests and decrypt the JWT tokens.
 &lt;!--stackedit_data:
-eyJoaXN0b3J5IjpbMTExNjg1ODVdfQ==
+eyJoaXN0b3J5IjpbLTE4Nzg1Nzg0NTZdfQ==
 --&gt;
&lt;!--stackedit_data:
eyJoaXN0b3J5IjpbLTU3MDEzOTUsMjY2MDE4ODY5LC01NzAxMz
k1LDI2NjAxODg2OV19
--&gt;</p>
